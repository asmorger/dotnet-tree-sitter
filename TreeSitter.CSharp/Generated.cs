//----------------------
// <auto-generated>
//     Generated by node_generator.py
//     source: langs-native/tree-sitter-c-sharp/src/node-types.json
// </auto-generated>
//----------------------

#nullable enable

using System.Linq;

namespace TreeSitter.CSharp.Nodes {

    public abstract class CSharpLanguageNode
    {
        public static CSharpLanguageNode FromNode(TreeSitter.Node node) {
            if (node is null) throw new System.ArgumentNullException(nameof(node));
            if (!node.IsNamed) return new CSharpLanguageNodeTerminalNode(node);
            switch (node.Kind) {
                case "range_expression": return new RangeExpression(node);
                case "variable_declarator": return new VariableDeclarator(node);
                case "comment": return new Comment(node);
                case "predefined_type": return new PredefinedType(node);
                case "arrow_expression_clause": return new ArrowExpressionClause(node);
                case "yield_statement": return new YieldStatement(node);
                case "primary_constructor_base_type": return new PrimaryConstructorBaseType(node);
                case "anonymous_object_creation_expression": return new AnonymousObjectCreationExpression(node);
                case "for_statement": return new ForStatement(node);
                case "constructor_constraint": return new ConstructorConstraint(node);
                case "interpolation_brace": return new InterpolationBrace(node);
                case "attribute_argument_list": return new AttributeArgumentList(node);
                case "qualified_name": return new QualifiedName(node);
                case "scoped_type": return new ScopedType(node);
                case "operator_declaration": return new OperatorDeclaration(node);
                case "preproc_arg": return new PreprocArg(node);
                case "unary_expression": return new UnaryExpression(node);
                case "raw_string_content": return new RawStringContent(node);
                case "as_expression": return new AsExpression(node);
                case "join_clause": return new JoinClause(node);
                case "struct_declaration": return new StructDeclaration(node);
                case "var_pattern": return new VarPattern(node);
                case "property_pattern_clause": return new PropertyPatternClause(node);
                case "default_expression": return new DefaultExpression(node);
                case "checked_statement": return new CheckedStatement(node);
                case "enum_member_declaration_list": return new EnumMemberDeclarationList(node);
                case "string_literal": return new StringLiteral(node);
                case "break_statement": return new BreakStatement(node);
                case "type_pattern": return new TypePattern(node);
                case "member_binding_expression": return new MemberBindingExpression(node);
                case "makeref_expression": return new MakerefExpression(node);
                case "ref_type": return new RefType(node);
                case "global_attribute": return new GlobalAttribute(node);
                case "pointer_type": return new PointerType(node);
                case "implicit_type": return new ImplicitType(node);
                case "select_clause": return new SelectClause(node);
                case "anonymous_method_expression": return new AnonymousMethodExpression(node);
                case "event_declaration": return new EventDeclaration(node);
                case "do_statement": return new DoStatement(node);
                case "preproc_if": return new PreprocIf(node);
                case "stackalloc_expression": return new StackallocExpression(node);
                case "group_clause": return new GroupClause(node);
                case "await_expression": return new AwaitExpression(node);
                case "catch_clause": return new CatchClause(node);
                case "join_into_clause": return new JoinIntoClause(node);
                case "nullable_type": return new NullableType(node);
                case "while_statement": return new WhileStatement(node);
                case "null_literal": return new NullLiteral(node);
                case "switch_statement": return new SwitchStatement(node);
                case "subpattern": return new Subpattern(node);
                case "conditional_expression": return new ConditionalExpression(node);
                case "file_scoped_namespace_declaration": return new FileScopedNamespaceDeclaration(node);
                case "parenthesized_variable_designation": return new ParenthesizedVariableDesignation(node);
                case "switch_section": return new SwitchSection(node);
                case "string_content": return new StringContent(node);
                case "attribute_target_specifier": return new AttributeTargetSpecifier(node);
                case "local_declaration_statement": return new LocalDeclarationStatement(node);
                case "argument_list": return new ArgumentList(node);
                case "continue_statement": return new ContinueStatement(node);
                case "implicit_object_creation_expression": return new ImplicitObjectCreationExpression(node);
                case "foreach_statement": return new ForeachStatement(node);
                case "parameter": return new Parameter(node);
                case "unsafe_statement": return new UnsafeStatement(node);
                case "postfix_unary_expression": return new PostfixUnaryExpression(node);
                case "where_clause": return new WhereClause(node);
                case "interpolated_string_expression": return new InterpolatedStringExpression(node);
                case "preproc_undef": return new PreprocUndef(node);
                case "array_type": return new ArrayType(node);
                case "preproc_nullable": return new PreprocNullable(node);
                case "using_directive": return new UsingDirective(node);
                case "lock_statement": return new LockStatement(node);
                case "event_field_declaration": return new EventFieldDeclaration(node);
                case "compilation_unit": return new CompilationUnit(node);
                case "assignment_expression": return new AssignmentExpression(node);
                case "when_clause": return new WhenClause(node);
                case "field_declaration": return new FieldDeclaration(node);
                case "preproc_error": return new PreprocError(node);
                case "query_expression": return new QueryExpression(node);
                case "switch_expression_arm": return new SwitchExpressionArm(node);
                case "alias_qualified_name": return new AliasQualifiedName(node);
                case "string_literal_content": return new StringLiteralContent(node);
                case "function_pointer_type": return new FunctionPointerType(node);
                case "modifier": return new Modifier(node);
                case "function_pointer_parameter": return new FunctionPointerParameter(node);
                case "type_argument_list": return new TypeArgumentList(node);
                case "interpolation_alignment_clause": return new InterpolationAlignmentClause(node);
                case "namespace_declaration": return new NamespaceDeclaration(node);
                case "enum_declaration": return new EnumDeclaration(node);
                case "throw_statement": return new ThrowStatement(node);
                case "enum_member_declaration": return new EnumMemberDeclaration(node);
                case "integer_literal": return new IntegerLiteral(node);
                case "interface_declaration": return new InterfaceDeclaration(node);
                case "destructor_declaration": return new DestructorDeclaration(node);
                case "interpolation": return new Interpolation(node);
                case "prefix_unary_expression": return new PrefixUnaryExpression(node);
                case "labeled_statement": return new LabeledStatement(node);
                case "reftype_expression": return new ReftypeExpression(node);
                case "let_clause": return new LetClause(node);
                case "list_pattern": return new ListPattern(node);
                case "recursive_pattern": return new RecursivePattern(node);
                case "attribute": return new Attribute(node);
                case "verbatim_string_literal": return new VerbatimStringLiteral(node);
                case "empty_statement": return new EmptyStatement(node);
                case "sizeof_expression": return new SizeofExpression(node);
                case "implicit_parameter": return new ImplicitParameter(node);
                case "lambda_expression": return new LambdaExpression(node);
                case "typeof_expression": return new TypeofExpression(node);
                case "preproc_else": return new PreprocElse(node);
                case "string_literal_encoding": return new StringLiteralEncoding(node);
                case "interpolation_quote": return new InterpolationQuote(node);
                case "element_binding_expression": return new ElementBindingExpression(node);
                case "finally_clause": return new FinallyClause(node);
                case "parenthesized_expression": return new ParenthesizedExpression(node);
                case "try_statement": return new TryStatement(node);
                case "accessor_declaration": return new AccessorDeclaration(node);
                case "declaration_pattern": return new DeclarationPattern(node);
                case "conversion_operator_declaration": return new ConversionOperatorDeclaration(node);
                case "tuple_element": return new TupleElement(node);
                case "parenthesized_pattern": return new ParenthesizedPattern(node);
                case "preproc_elif": return new PreprocElif(node);
                case "initializer_expression": return new InitializerExpression(node);
                case "with_initializer": return new WithInitializer(node);
                case "implicit_stackalloc_expression": return new ImplicitStackallocExpression(node);
                case "return_statement": return new ReturnStatement(node);
                case "throw_expression": return new ThrowExpression(node);
                case "cast_expression": return new CastExpression(node);
                case "constant_pattern": return new ConstantPattern(node);
                case "extern_alias_directive": return new ExternAliasDirective(node);
                case "and_pattern": return new AndPattern(node);
                case "using_statement": return new UsingStatement(node);
                case "preproc_define": return new PreprocDefine(node);
                case "preproc_endregion": return new PreprocEndregion(node);
                case "constructor_initializer": return new ConstructorInitializer(node);
                case "character_literal_content": return new CharacterLiteralContent(node);
                case "goto_statement": return new GotoStatement(node);
                case "local_function_statement": return new LocalFunctionStatement(node);
                case "calling_convention": return new CallingConvention(node);
                case "element_access_expression": return new ElementAccessExpression(node);
                case "method_declaration": return new MethodDeclaration(node);
                case "raw_string_end": return new RawStringEnd(node);
                case "character_literal": return new CharacterLiteral(node);
                case "preproc_pragma": return new PreprocPragma(node);
                case "argument": return new Argument(node);
                case "boolean_literal": return new BooleanLiteral(node);
                case "is_expression": return new IsExpression(node);
                case "type_parameter_constraint": return new TypeParameterConstraint(node);
                case "constructor_declaration": return new ConstructorDeclaration(node);
                case "tuple_type": return new TupleType(node);
                case "record_declaration": return new RecordDeclaration(node);
                case "array_rank_specifier": return new ArrayRankSpecifier(node);
                case "relational_pattern": return new RelationalPattern(node);
                case "member_access_expression": return new MemberAccessExpression(node);
                case "declaration_expression": return new DeclarationExpression(node);
                case "type_parameter_constraints_clause": return new TypeParameterConstraintsClause(node);
                case "conditional_access_expression": return new ConditionalAccessExpression(node);
                case "attribute_list": return new AttributeList(node);
                case "from_clause": return new FromClause(node);
                case "switch_body": return new SwitchBody(node);
                case "refvalue_expression": return new RefvalueExpression(node);
                case "preproc_if_in_attribute_list": return new PreprocIfInAttributeList(node);
                case "ref_expression": return new RefExpression(node);
                case "raw_string_start": return new RawStringStart(node);
                case "variable_declaration": return new VariableDeclaration(node);
                case "binary_expression": return new BinaryExpression(node);
                case "delegate_declaration": return new DelegateDeclaration(node);
                case "or_pattern": return new OrPattern(node);
                case "switch_expression": return new SwitchExpression(node);
                case "catch_filter_clause": return new CatchFilterClause(node);
                case "indexer_declaration": return new IndexerDeclaration(node);
                case "property_declaration": return new PropertyDeclaration(node);
                case "base_list": return new BaseList(node);
                case "positional_pattern_clause": return new PositionalPatternClause(node);
                case "global_statement": return new GlobalStatement(node);
                case "generic_name": return new GenericName(node);
                case "identifier": return new Identifier(node);
                case "implicit_array_creation_expression": return new ImplicitArrayCreationExpression(node);
                case "bracketed_argument_list": return new BracketedArgumentList(node);
                case "negated_pattern": return new NegatedPattern(node);
                case "type_parameter_list": return new TypeParameterList(node);
                case "tuple_pattern": return new TuplePattern(node);
                case "accessor_list": return new AccessorList(node);
                case "array_creation_expression": return new ArrayCreationExpression(node);
                case "fixed_statement": return new FixedStatement(node);
                case "escape_sequence": return new EscapeSequence(node);
                case "block": return new Block(node);
                case "preproc_line": return new PreprocLine(node);
                case "expression_statement": return new ExpressionStatement(node);
                case "attribute_argument": return new AttributeArgument(node);
                case "class_declaration": return new ClassDeclaration(node);
                case "raw_string_literal": return new RawStringLiteral(node);
                case "checked_expression": return new CheckedExpression(node);
                case "bracketed_parameter_list": return new BracketedParameterList(node);
                case "with_expression": return new WithExpression(node);
                case "is_pattern_expression": return new IsPatternExpression(node);
                case "order_by_clause": return new OrderByClause(node);
                case "real_literal": return new RealLiteral(node);
                case "catch_declaration": return new CatchDeclaration(node);
                case "type_parameter": return new TypeParameter(node);
                case "discard": return new Discard(node);
                case "explicit_interface_specifier": return new ExplicitInterfaceSpecifier(node);
                case "parameter_list": return new ParameterList(node);
                case "preproc_warning": return new PreprocWarning(node);
                case "object_creation_expression": return new ObjectCreationExpression(node);
                case "interpolation_format_clause": return new InterpolationFormatClause(node);
                case "preproc_region": return new PreprocRegion(node);
                case "declaration_list": return new DeclarationList(node);
                case "tuple_expression": return new TupleExpression(node);
                case "invocation_expression": return new InvocationExpression(node);
                case "shebang_directive": return new ShebangDirective(node);
                case "if_statement": return new IfStatement(node);
                case "interpolation_start": return new InterpolationStart(node);
                case "ERROR": return new ErrorNode(node);
                default: throw new System.ArgumentException("unknown node type: " + node.Kind, nameof(node));
            }
        }

    
        public string Kind { get; set; }

        protected CSharpLanguageNode(TreeSitter.Node node)
        {
            Kind = node.Kind;
        }
    }
    
    public class CSharpLanguageNodeTerminalNode : CSharpLanguageNode
    {
        public CSharpLanguageNodeTerminalNode(TreeSitter.Node node) : base(node)
        {
        }
    }
    
    public class ErrorNode : CSharpLanguageNode
    {
        public ErrorNode(TreeSitter.Node node) : base(node)
        {
        }
    }

    public interface Declaration
    {
    }

    public interface Expression
    {
    }

    public interface Literal : NonLvalueExpression
    {
    }

    public interface LvalueExpression : Expression
    {
    }

    public interface NonLvalueExpression : Expression
    {
    }

    public interface Pattern
    {
    }

    public interface Statement
    {
    }

    public interface Type
    {
    }

    public interface TypeDeclaration
    {
    }

    public class AccessorDeclaration : CSharpLanguageNode
    {
        public CSharpLanguageNode? Body { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AccessorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "accessor_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AccessorList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<AccessorDeclaration> Children { get; set; }
        public AccessorList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "accessor_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AccessorDeclaration(x)).ToList();
        }
    }

    public class AliasQualifiedName : CSharpLanguageNode, Type
    {
        public Identifier Alias { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public AliasQualifiedName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "alias_qualified_name");
            
            this.Alias = new Identifier(node.ChildByFieldName("alias"));
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class AndPattern : CSharpLanguageNode, Pattern
    {
        public Pattern Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public Pattern Right { get; set; }
        public AndPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "and_pattern");
            
            this.Left = (Pattern) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Pattern) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AnonymousMethodExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public ParameterList? Parameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AnonymousMethodExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "anonymous_method_expression");
            
            {
                var tmp = node.ChildByFieldName("parameters");
                this.Parameters = tmp is null ? null : new ParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AnonymousObjectCreationExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AnonymousObjectCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "anonymous_object_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Argument : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Argument(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "argument");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public ArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class ArrayCreationExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public ArrayType Type { get; set; }
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public ArrayCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_creation_expression");
            
            this.Type = new ArrayType(node.ChildByFieldName("type"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class ArrayRankSpecifier : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ArrayRankSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_rank_specifier");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrayType : CSharpLanguageNode, Type
    {
        public ArrayRankSpecifier Rank { get; set; }
        public CSharpLanguageNode Type { get; set; }
        public ArrayType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_type");
            
            this.Rank = new ArrayRankSpecifier(node.ChildByFieldName("rank"));
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class ArrowExpressionClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ArrowExpressionClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "arrow_expression_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AsExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Expression Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public Type Right { get; set; }
        public AsExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "as_expression");
            
            this.Left = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AssignmentExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public LvalueExpression Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public Expression Right { get; set; }
        public AssignmentExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "assignment_expression");
            
            this.Left = (LvalueExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class Attribute : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public System.Collections.Generic.List<AttributeArgumentList> Children { get; set; }
        public Attribute(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeArgumentList(x)).ToList();
        }
    }

    public class AttributeArgument : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AttributeArgument(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_argument");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AttributeArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<AttributeArgument> Children { get; set; }
        public AttributeArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeArgument(x)).ToList();
        }
    }

    public class AttributeList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AttributeList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AttributeTargetSpecifier : CSharpLanguageNode
    {
        public AttributeTargetSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_target_specifier");
            
        }
    }

    public class AwaitExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public AwaitExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "await_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BaseList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public BaseList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "base_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BinaryExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public CSharpLanguageNode Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public CSharpLanguageNode Right { get; set; }
        public BinaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "binary_expression");
            
            this.Left = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class Block : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Statement> Children { get; set; }
        public Block(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Statement) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BooleanLiteral : CSharpLanguageNode, Literal
    {
        public BooleanLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "boolean_literal");
            
        }
    }

    public class BracketedArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public BracketedArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "bracketed_argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class BracketedParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public BracketedParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "bracketed_parameter_list");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Type = node.ChildrenByFieldName("type").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BreakStatement : CSharpLanguageNode, Statement
    {
        public BreakStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "break_statement");
            
        }
    }

    public class CallingConvention : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public CallingConvention(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "calling_convention");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class CastExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Type Type { get; set; }
        public Expression Value { get; set; }
        public CastExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "cast_expression");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Value = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class CatchClause : CSharpLanguageNode
    {
        public Block Body { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CatchClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_clause");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CatchDeclaration : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public Type Type { get; set; }
        public CatchDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_declaration");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class CatchFilterClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public CatchFilterClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_filter_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CharacterLiteral : CSharpLanguageNode, Literal
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CharacterLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "character_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CheckedExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public CheckedExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "checked_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CheckedStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public CheckedStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "checked_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class ClassDeclaration : CSharpLanguageNode, Declaration, TypeDeclaration
    {
        public DeclarationList? Body { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ClassDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CompilationUnit : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CompilationUnit(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "compilation_unit");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConditionalAccessExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Expression Condition { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConditionalAccessExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conditional_access_expression");
            
            this.Condition = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConditionalExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Expression Alternative { get; set; }
        public Expression Condition { get; set; }
        public Expression Consequence { get; set; }
        public ConditionalExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conditional_expression");
            
            this.Alternative = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("alternative"))!;
            this.Condition = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Consequence = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
        }
    }

    public class ConstantPattern : CSharpLanguageNode, Pattern
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConstantPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constant_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConstructorConstraint : CSharpLanguageNode
    {
        public ConstructorConstraint(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_constraint");
            
        }
    }

    public class ConstructorDeclaration : CSharpLanguageNode, Declaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConstructorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConstructorInitializer : CSharpLanguageNode
    {
        public System.Collections.Generic.List<ArgumentList> Children { get; set; }
        public ConstructorInitializer(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_initializer");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ArgumentList(x)).ToList();
        }
    }

    public class ContinueStatement : CSharpLanguageNode, Statement
    {
        public ContinueStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "continue_statement");
            
        }
    }

    public class ConversionOperatorDeclaration : CSharpLanguageNode, Declaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public ParameterList Parameters { get; set; }
        public Type Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConversionOperatorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conversion_operator_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DeclarationExpression : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public Type Type { get; set; }
        public DeclarationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_expression");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class DeclarationList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Declaration> Children { get; set; }
        public DeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Declaration) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DeclarationPattern : CSharpLanguageNode, Pattern
    {
        public Identifier? Name { get; set; }
        public Type Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public DeclarationPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DefaultExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Type? Type { get; set; }
        public DefaultExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "default_expression");
            
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
        }
    }

    public class DelegateDeclaration : CSharpLanguageNode, Declaration, TypeDeclaration
    {
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public Type Type { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public DelegateDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "delegate_declaration");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DestructorDeclaration : CSharpLanguageNode, Declaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public DestructorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "destructor_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DoStatement : CSharpLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public Expression Condition { get; set; }
        public DoStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "do_statement");
            
            this.Body = (Statement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Condition = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
        }
    }

    public class ElementAccessExpression : CSharpLanguageNode, LvalueExpression
    {
        public Expression Expression { get; set; }
        public BracketedArgumentList Subscript { get; set; }
        public ElementAccessExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "element_access_expression");
            
            this.Expression = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("expression"))!;
            this.Subscript = new BracketedArgumentList(node.ChildByFieldName("subscript"));
        }
    }

    public class ElementBindingExpression : CSharpLanguageNode, LvalueExpression
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public ElementBindingExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "element_binding_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class EmptyStatement : CSharpLanguageNode, Statement
    {
        public EmptyStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "empty_statement");
            
        }
    }

    public class EnumDeclaration : CSharpLanguageNode, Declaration, TypeDeclaration
    {
        public EnumMemberDeclarationList? Body { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EnumDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new EnumMemberDeclarationList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EnumMemberDeclaration : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public Expression? Value { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EnumMemberDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_member_declaration");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EnumMemberDeclarationList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EnumMemberDeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_member_declaration_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EventDeclaration : CSharpLanguageNode, Declaration
    {
        public AccessorList? Accessors { get; set; }
        public Identifier Name { get; set; }
        public Type Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EventDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "event_declaration");
            
            {
                var tmp = node.ChildByFieldName("accessors");
                this.Accessors = tmp is null ? null : new AccessorList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EventFieldDeclaration : CSharpLanguageNode, Declaration
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EventFieldDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "event_field_declaration");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExplicitInterfaceSpecifier : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ExplicitInterfaceSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "explicit_interface_specifier");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExpressionStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ExpressionStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "expression_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExternAliasDirective : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public ExternAliasDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "extern_alias_directive");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
        }
    }

    public class FieldDeclaration : CSharpLanguageNode, Declaration
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FieldDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_declaration");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FileScopedNamespaceDeclaration : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public FileScopedNamespaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "file_scoped_namespace_declaration");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class FinallyClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public FinallyClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "finally_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class FixedStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FixedStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "fixed_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ForStatement : CSharpLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public Expression? Condition { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Initializer { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Update { get; set; }
        public ForStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_statement");
            
            this.Body = (Statement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            {
                var tmp = node.ChildByFieldName("condition");
                this.Condition = tmp is null ? null : (Expression) CSharpLanguageNode.FromNode(tmp);
            }
            this.Initializer = node.ChildrenByFieldName("initializer").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Update = node.ChildrenByFieldName("update").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ForeachStatement : CSharpLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public CSharpLanguageNode Left { get; set; }
        public Expression Right { get; set; }
        public Type? Type { get; set; }
        public ForeachStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "foreach_statement");
            
            this.Body = (Statement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Left = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
        }
    }

    public class FromClause : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public Type? Type { get; set; }
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public FromClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "from_clause");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FunctionPointerParameter : CSharpLanguageNode
    {
        public CSharpLanguageNode Type { get; set; }
        public FunctionPointerParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_parameter");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class FunctionPointerType : CSharpLanguageNode, Type
    {
        public Type Returns { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FunctionPointerType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_type");
            
            this.Returns = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("returns"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GenericName : CSharpLanguageNode, LvalueExpression, Type
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public GenericName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_name");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GlobalAttribute : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Attribute> Children { get; set; }
        public GlobalAttribute(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "global_attribute");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Attribute(x)).ToList();
        }
    }

    public class GlobalStatement : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Statement> Children { get; set; }
        public GlobalStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "global_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Statement) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GotoStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public GotoStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "goto_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GroupClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public GroupClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "group_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Identifier : CSharpLanguageNode, LvalueExpression, Type
    {
        public Identifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "identifier");
            
        }
    }

    public class IfStatement : CSharpLanguageNode, Statement
    {
        public Statement? Alternative { get; set; }
        public Expression Condition { get; set; }
        public Statement Consequence { get; set; }
        public IfStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "if_statement");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : (Statement) CSharpLanguageNode.FromNode(tmp);
            }
            this.Condition = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Consequence = (Statement) CSharpLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
        }
    }

    public class ImplicitArrayCreationExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public ImplicitArrayCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_array_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class ImplicitObjectCreationExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ImplicitObjectCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_object_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ImplicitParameter : CSharpLanguageNode
    {
        public ImplicitParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_parameter");
            
        }
    }

    public class ImplicitStackallocExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public ImplicitStackallocExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_stackalloc_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class ImplicitType : CSharpLanguageNode, Type
    {
        public ImplicitType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_type");
            
        }
    }

    public class IndexerDeclaration : CSharpLanguageNode, Declaration
    {
        public AccessorList? Accessors { get; set; }
        public BracketedParameterList Parameters { get; set; }
        public Type Type { get; set; }
        public ArrowExpressionClause? Value { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public IndexerDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "indexer_declaration");
            
            {
                var tmp = node.ChildByFieldName("accessors");
                this.Accessors = tmp is null ? null : new AccessorList(tmp);
            }
            this.Parameters = new BracketedParameterList(node.ChildByFieldName("parameters"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : new ArrowExpressionClause(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InitializerExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public InitializerExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "initializer_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterfaceDeclaration : CSharpLanguageNode, Declaration, TypeDeclaration
    {
        public DeclarationList? Body { get; set; }
        public Identifier Name { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public InterfaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interface_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolatedStringExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public InterpolatedStringExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolated_string_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Interpolation : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Interpolation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolationAlignmentClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public InterpolationAlignmentClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_alignment_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolationFormatClause : CSharpLanguageNode
    {
        public InterpolationFormatClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_format_clause");
            
        }
    }

    public class InvocationExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public ArgumentList Arguments { get; set; }
        public Expression Function { get; set; }
        public InvocationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "invocation_expression");
            
            this.Arguments = new ArgumentList(node.ChildByFieldName("arguments"));
            this.Function = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("function"))!;
        }
    }

    public class IsExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Expression Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public Type Right { get; set; }
        public IsExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "is_expression");
            
            this.Left = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class IsPatternExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Expression Expression { get; set; }
        public Pattern Pattern { get; set; }
        public IsPatternExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "is_pattern_expression");
            
            this.Expression = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("expression"))!;
            this.Pattern = (Pattern) CSharpLanguageNode.FromNode(node.ChildByFieldName("pattern"))!;
        }
    }

    public class JoinClause : CSharpLanguageNode
    {
        public Type? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public JoinClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "join_clause");
            
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JoinIntoClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public JoinIntoClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "join_into_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class LabeledStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LabeledStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "labeled_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LambdaExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public CSharpLanguageNode Body { get; set; }
        public CSharpLanguageNode Parameters { get; set; }
        public Type? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LambdaExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lambda_expression");
            
            this.Body = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Parameters = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("parameters"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LetClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LetClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "let_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ListPattern : CSharpLanguageNode, Pattern
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ListPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "list_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LocalDeclarationStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LocalDeclarationStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "local_declaration_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LocalFunctionStatement : CSharpLanguageNode, Statement
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public Type Type { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LocalFunctionStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "local_function_statement");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LockStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LockStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lock_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MakerefExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public MakerefExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "makeref_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MemberAccessExpression : CSharpLanguageNode, LvalueExpression
    {
        public CSharpLanguageNode Expression { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public MemberAccessExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "member_access_expression");
            
            this.Expression = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("expression"))!;
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class MemberBindingExpression : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public MemberBindingExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "member_binding_expression");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class MethodDeclaration : CSharpLanguageNode, Declaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public Type Returns { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public MethodDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "method_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Returns = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("returns"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Modifier : CSharpLanguageNode
    {
        public Modifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "modifier");
            
        }
    }

    public class NamespaceDeclaration : CSharpLanguageNode, Declaration
    {
        public DeclarationList Body { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public NamespaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "namespace_declaration");
            
            this.Body = new DeclarationList(node.ChildByFieldName("body"));
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class NegatedPattern : CSharpLanguageNode, Pattern
    {
        public System.Collections.Generic.List<Pattern> Children { get; set; }
        public NegatedPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "negated_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Pattern) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NullableType : CSharpLanguageNode, Type
    {
        public CSharpLanguageNode Type { get; set; }
        public NullableType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "nullable_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class ObjectCreationExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public ArgumentList? Arguments { get; set; }
        public InitializerExpression? Initializer { get; set; }
        public Type Type { get; set; }
        public ObjectCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "object_creation_expression");
            
            {
                var tmp = node.ChildByFieldName("arguments");
                this.Arguments = tmp is null ? null : new ArgumentList(tmp);
            }
            {
                var tmp = node.ChildByFieldName("initializer");
                this.Initializer = tmp is null ? null : new InitializerExpression(tmp);
            }
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class OperatorDeclaration : CSharpLanguageNode, Declaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public ParameterList Parameters { get; set; }
        public Type Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public OperatorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "operator_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OrPattern : CSharpLanguageNode, Pattern
    {
        public Pattern Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public Pattern Right { get; set; }
        public OrPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "or_pattern");
            
            this.Left = (Pattern) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Pattern) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class OrderByClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public OrderByClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "order_by_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Parameter : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public Type? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Parameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameter");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameter_list");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Type = node.ChildrenByFieldName("type").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedExpression : CSharpLanguageNode, LvalueExpression, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParenthesizedExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedPattern : CSharpLanguageNode, Pattern
    {
        public System.Collections.Generic.List<Pattern> Children { get; set; }
        public ParenthesizedPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Pattern) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedVariableDesignation : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParenthesizedVariableDesignation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_variable_designation");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PointerType : CSharpLanguageNode, Type
    {
        public CSharpLanguageNode Type { get; set; }
        public PointerType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "pointer_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class PositionalPatternClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Subpattern> Children { get; set; }
        public PositionalPatternClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "positional_pattern_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Subpattern(x)).ToList();
        }
    }

    public class PostfixUnaryExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public PostfixUnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "postfix_unary_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PrefixUnaryExpression : CSharpLanguageNode, LvalueExpression, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public PrefixUnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "prefix_unary_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PreprocDefine : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocArg> Children { get; set; }
        public PreprocDefine(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_define");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocArg(x)).ToList();
        }
    }

    public class PreprocElif : CSharpLanguageNode
    {
        public CSharpLanguageNode? Alternative { get; set; }
        public CSharpLanguageNode Condition { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PreprocElif(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_elif");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Condition = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PreprocElse : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PreprocElse(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_else");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PreprocEndregion : CSharpLanguageNode
    {
        public PreprocArg? Content { get; set; }
        public PreprocEndregion(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_endregion");
            
            {
                var tmp = node.ChildByFieldName("content");
                this.Content = tmp is null ? null : new PreprocArg(tmp);
            }
        }
    }

    public class PreprocError : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocArg> Children { get; set; }
        public PreprocError(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_error");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocArg(x)).ToList();
        }
    }

    public class PreprocIf : CSharpLanguageNode, Declaration, NonLvalueExpression, Statement
    {
        public CSharpLanguageNode? Alternative { get; set; }
        public CSharpLanguageNode Condition { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PreprocIf(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_if");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Condition = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PreprocIfInAttributeList : CSharpLanguageNode
    {
        public CSharpLanguageNode? Alternative { get; set; }
        public CSharpLanguageNode Condition { get; set; }
        public System.Collections.Generic.List<AttributeList> Children { get; set; }
        public PreprocIfInAttributeList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_if_in_attribute_list");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Condition = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeList(x)).ToList();
        }
    }

    public class PreprocLine : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PreprocLine(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_line");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PreprocNullable : CSharpLanguageNode
    {
        public PreprocNullable(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_nullable");
            
        }
    }

    public class PreprocPragma : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PreprocPragma(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_pragma");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PreprocRegion : CSharpLanguageNode
    {
        public PreprocArg? Content { get; set; }
        public PreprocRegion(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_region");
            
            {
                var tmp = node.ChildByFieldName("content");
                this.Content = tmp is null ? null : new PreprocArg(tmp);
            }
        }
    }

    public class PreprocUndef : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocArg> Children { get; set; }
        public PreprocUndef(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_undef");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocArg(x)).ToList();
        }
    }

    public class PreprocWarning : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocArg> Children { get; set; }
        public PreprocWarning(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_warning");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocArg(x)).ToList();
        }
    }

    public class PrimaryConstructorBaseType : CSharpLanguageNode
    {
        public CSharpLanguageNode Type { get; set; }
        public System.Collections.Generic.List<ArgumentList> Children { get; set; }
        public PrimaryConstructorBaseType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "primary_constructor_base_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ArgumentList(x)).ToList();
        }
    }

    public class PropertyDeclaration : CSharpLanguageNode, Declaration
    {
        public AccessorList? Accessors { get; set; }
        public Identifier Name { get; set; }
        public Type Type { get; set; }
        public CSharpLanguageNode? Value { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PropertyDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "property_declaration");
            
            {
                var tmp = node.ChildByFieldName("accessors");
                this.Accessors = tmp is null ? null : new AccessorList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PropertyPatternClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Subpattern> Children { get; set; }
        public PropertyPatternClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "property_pattern_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Subpattern(x)).ToList();
        }
    }

    public class QualifiedName : CSharpLanguageNode, Type
    {
        public CSharpLanguageNode Name { get; set; }
        public CSharpLanguageNode Qualifier { get; set; }
        public QualifiedName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "qualified_name");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Qualifier = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("qualifier"))!;
        }
    }

    public class QueryExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public QueryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "query_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RangeExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public RangeExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "range_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RawStringLiteral : CSharpLanguageNode, Literal
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public RawStringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "raw_string_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RecordDeclaration : CSharpLanguageNode, Declaration, TypeDeclaration
    {
        public DeclarationList? Body { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public RecordDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "record_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RecursivePattern : CSharpLanguageNode, Pattern
    {
        public Identifier? Name { get; set; }
        public Type? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public RecursivePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "recursive_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RefExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public RefExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RefType : CSharpLanguageNode, Type
    {
        public Type Type { get; set; }
        public RefType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_type");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class ReftypeExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ReftypeExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "reftype_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RefvalueExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Type Type { get; set; }
        public Expression Value { get; set; }
        public RefvalueExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "refvalue_expression");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Value = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class RelationalPattern : CSharpLanguageNode, Pattern
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public RelationalPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "relational_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReturnStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ReturnStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "return_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ScopedType : CSharpLanguageNode, Type
    {
        public CSharpLanguageNode Type { get; set; }
        public ScopedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "scoped_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class SelectClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public SelectClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "select_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SizeofExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Type Type { get; set; }
        public SizeofExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "sizeof_expression");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class StackallocExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public ArrayType Type { get; set; }
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public StackallocExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "stackalloc_expression");
            
            this.Type = new ArrayType(node.ChildByFieldName("type"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class StringLiteral : CSharpLanguageNode, Literal
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public StringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StringLiteralContent : CSharpLanguageNode
    {
        public StringLiteralContent(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal_content");
            
        }
    }

    public class StructDeclaration : CSharpLanguageNode, Declaration, TypeDeclaration
    {
        public DeclarationList? Body { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public StructDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "struct_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Subpattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Subpattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "subpattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchBody : CSharpLanguageNode
    {
        public System.Collections.Generic.List<SwitchSection> Children { get; set; }
        public SwitchBody(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_body");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new SwitchSection(x)).ToList();
        }
    }

    public class SwitchExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public SwitchExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchExpressionArm : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public SwitchExpressionArm(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_expression_arm");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchSection : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public SwitchSection(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_section");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchStatement : CSharpLanguageNode, Statement
    {
        public SwitchBody Body { get; set; }
        public CSharpLanguageNode Value { get; set; }
        public SwitchStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_statement");
            
            this.Body = new SwitchBody(node.ChildByFieldName("body"));
            this.Value = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class ThrowExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ThrowExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "throw_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ThrowStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ThrowStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "throw_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TryStatement : CSharpLanguageNode, Statement
    {
        public Block Body { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TryStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "try_statement");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleElement : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public Type Type { get; set; }
        public TupleElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_element");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class TupleExpression : CSharpLanguageNode, LvalueExpression
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public TupleExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class TuplePattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TuplePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_pattern");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleType : CSharpLanguageNode, Type
    {
        public System.Collections.Generic.List<TupleElement> Children { get; set; }
        public TupleType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TupleElement(x)).ToList();
        }
    }

    public class TypeArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Type> Children { get; set; }
        public TypeArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Type) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeParameter : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TypeParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeParameterConstraint : CSharpLanguageNode
    {
        public Type? Type { get; set; }
        public System.Collections.Generic.List<ConstructorConstraint> Children { get; set; }
        public TypeParameterConstraint(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter_constraint");
            
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (Type) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ConstructorConstraint(x)).ToList();
        }
    }

    public class TypeParameterConstraintsClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TypeParameterConstraintsClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter_constraints_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<TypeParameter> Children { get; set; }
        public TypeParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TypeParameter(x)).ToList();
        }
    }

    public class TypePattern : CSharpLanguageNode, Pattern
    {
        public Type Type { get; set; }
        public TypePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_pattern");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class TypeofExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public Type Type { get; set; }
        public TypeofExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "typeof_expression");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class UnaryExpression : CSharpLanguageNode
    {
        public CSharpLanguageNode Argument { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public UnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unary_expression");
            
            this.Argument = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("argument"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
        }
    }

    public class UnsafeStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public UnsafeStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unsafe_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class UsingDirective : CSharpLanguageNode, Declaration
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<Type> Children { get; set; }
        public UsingDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "using_directive");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Type) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UsingStatement : CSharpLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public UsingStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "using_statement");
            
            this.Body = (Statement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class VarPattern : CSharpLanguageNode, Pattern
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public VarPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "var_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class VariableDeclaration : CSharpLanguageNode
    {
        public Type Type { get; set; }
        public System.Collections.Generic.List<VariableDeclarator> Children { get; set; }
        public VariableDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variable_declaration");
            
            this.Type = (Type) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VariableDeclarator(x)).ToList();
        }
    }

    public class VariableDeclarator : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public VariableDeclarator(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variable_declarator");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WhenClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public WhenClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "when_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WhereClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public WhereClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "where_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WhileStatement : CSharpLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public Expression Condition { get; set; }
        public WhileStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "while_statement");
            
            this.Body = (Statement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Condition = (Expression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
        }
    }

    public class WithExpression : CSharpLanguageNode, NonLvalueExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public WithExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "with_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WithInitializer : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public WithInitializer(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "with_initializer");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class YieldStatement : CSharpLanguageNode, Statement
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public YieldStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "yield_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CharacterLiteralContent : CSharpLanguageNode
    {
        public CharacterLiteralContent(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "character_literal_content");
            
        }
    }

    public class Comment : CSharpLanguageNode
    {
        public Comment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "comment");
            
        }
    }

    public class Discard : CSharpLanguageNode, Pattern
    {
        public Discard(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "discard");
            
        }
    }

    public class EscapeSequence : CSharpLanguageNode
    {
        public EscapeSequence(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "escape_sequence");
            
        }
    }

    public class IntegerLiteral : CSharpLanguageNode, Literal
    {
        public IntegerLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "integer_literal");
            
        }
    }

    public class InterpolationBrace : CSharpLanguageNode
    {
        public InterpolationBrace(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_brace");
            
        }
    }

    public class InterpolationQuote : CSharpLanguageNode
    {
        public InterpolationQuote(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_quote");
            
        }
    }

    public class InterpolationStart : CSharpLanguageNode
    {
        public InterpolationStart(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_start");
            
        }
    }

    public class NullLiteral : CSharpLanguageNode, Literal
    {
        public NullLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "null_literal");
            
        }
    }

    public class PredefinedType : CSharpLanguageNode, Type
    {
        public PredefinedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "predefined_type");
            
        }
    }

    public class PreprocArg : CSharpLanguageNode
    {
        public PreprocArg(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_arg");
            
        }
    }

    public class RawStringContent : CSharpLanguageNode
    {
        public RawStringContent(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "raw_string_content");
            
        }
    }

    public class RawStringEnd : CSharpLanguageNode
    {
        public RawStringEnd(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "raw_string_end");
            
        }
    }

    public class RawStringStart : CSharpLanguageNode
    {
        public RawStringStart(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "raw_string_start");
            
        }
    }

    public class RealLiteral : CSharpLanguageNode, Literal
    {
        public RealLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "real_literal");
            
        }
    }

    public class ShebangDirective : CSharpLanguageNode
    {
        public ShebangDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shebang_directive");
            
        }
    }

    public class StringContent : CSharpLanguageNode
    {
        public StringContent(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_content");
            
        }
    }

    public class StringLiteralEncoding : CSharpLanguageNode
    {
        public StringLiteralEncoding(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal_encoding");
            
        }
    }

    public class VerbatimStringLiteral : CSharpLanguageNode, Literal
    {
        public VerbatimStringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "verbatim_string_literal");
            
        }
    }
}