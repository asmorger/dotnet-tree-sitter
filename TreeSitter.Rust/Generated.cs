//----------------------
// <auto-generated>
//     Generated by node_generator.py
//     source: langs-native/tree-sitter-rust/src/node-types.json
// </auto-generated>
//----------------------

#nullable enable

using System.Linq;

namespace TreeSitter.Rust.Nodes {

    public abstract class RustLanguageNode
    {
        public static RustLanguageNode FromNode(TreeSitter.Node node) {
            if (node is null) throw new System.ArgumentNullException(nameof(node));
            if (!node.IsNamed) return new RustLanguageNodeTerminalNode(node);
            switch (node.Kind) {
                case "attribute": return new Attribute(node);
                case "shorthand_field_initializer": return new ShorthandFieldInitializer(node);
                case "attribute_item": return new AttributeItem(node);
                case "slice_pattern": return new SlicePattern(node);
                case "ref_pattern": return new RefPattern(node);
                case "where_predicate": return new WherePredicate(node);
                case "char_literal": return new CharLiteral(node);
                case "use_as_clause": return new UseAsClause(node);
                case "dynamic_type": return new DynamicType(node);
                case "return_expression": return new ReturnExpression(node);
                case "unary_expression": return new UnaryExpression(node);
                case "else_clause": return new ElseClause(node);
                case "label": return new Label(node);
                case "field_declaration": return new FieldDeclaration(node);
                case "let_condition": return new LetCondition(node);
                case "foreign_mod_item": return new ForeignModItem(node);
                case "reference_expression": return new ReferenceExpression(node);
                case "identifier": return new Identifier(node);
                case "gen_block": return new GenBlock(node);
                case "macro_invocation": return new MacroInvocation(node);
                case "metavariable": return new Metavariable(node);
                case "field_identifier": return new FieldIdentifier(node);
                case "type_parameter": return new TypeParameter(node);
                case "extern_crate_declaration": return new ExternCrateDeclaration(node);
                case "inner_doc_comment_marker": return new InnerDocCommentMarker(node);
                case "async_block": return new AsyncBlock(node);
                case "string_literal": return new StringLiteral(node);
                case "if_expression": return new IfExpression(node);
                case "token_binding_pattern": return new TokenBindingPattern(node);
                case "continue_expression": return new ContinueExpression(node);
                case "tuple_type": return new TupleType(node);
                case "mod_item": return new ModItem(node);
                case "unit_type": return new UnitType(node);
                case "range_expression": return new RangeExpression(node);
                case "field_pattern": return new FieldPattern(node);
                case "let_declaration": return new LetDeclaration(node);
                case "use_list": return new UseList(node);
                case "float_literal": return new FloatLiteral(node);
                case "higher_ranked_trait_bound": return new HigherRankedTraitBound(node);
                case "negative_literal": return new NegativeLiteral(node);
                case "field_declaration_list": return new FieldDeclarationList(node);
                case "function_type": return new FunctionType(node);
                case "compound_assignment_expr": return new CompoundAssignmentExpr(node);
                case "field_initializer_list": return new FieldInitializerList(node);
                case "match_arm": return new MatchArm(node);
                case "reference_pattern": return new ReferencePattern(node);
                case "expression_statement": return new ExpressionStatement(node);
                case "primitive_type": return new PrimitiveType(node);
                case "integer_literal": return new IntegerLiteral(node);
                case "enum_item": return new EnumItem(node);
                case "match_expression": return new MatchExpression(node);
                case "crate": return new Crate(node);
                case "mutable_specifier": return new MutableSpecifier(node);
                case "yield_expression": return new YieldExpression(node);
                case "const_item": return new ConstItem(node);
                case "block_comment": return new BlockComment(node);
                case "try_expression": return new TryExpression(node);
                case "token_repetition_pattern": return new TokenRepetitionPattern(node);
                case "bounded_type": return new BoundedType(node);
                case "use_wildcard": return new UseWildcard(node);
                case "use_declaration": return new UseDeclaration(node);
                case "tuple_expression": return new TupleExpression(node);
                case "line_comment": return new LineComment(node);
                case "pointer_type": return new PointerType(node);
                case "type_cast_expression": return new TypeCastExpression(node);
                case "inner_attribute_item": return new InnerAttributeItem(node);
                case "lifetime_parameter": return new LifetimeParameter(node);
                case "scoped_type_identifier": return new ScopedTypeIdentifier(node);
                case "match_block": return new MatchBlock(node);
                case "unit_expression": return new UnitExpression(node);
                case "where_clause": return new WhereClause(node);
                case "unsafe_block": return new UnsafeBlock(node);
                case "array_expression": return new ArrayExpression(node);
                case "associated_type": return new AssociatedType(node);
                case "binary_expression": return new BinaryExpression(node);
                case "tuple_struct_pattern": return new TupleStructPattern(node);
                case "remaining_field_pattern": return new RemainingFieldPattern(node);
                case "field_initializer": return new FieldInitializer(node);
                case "struct_expression": return new StructExpression(node);
                case "shorthand_field_identifier": return new ShorthandFieldIdentifier(node);
                case "outer_doc_comment_marker": return new OuterDocCommentMarker(node);
                case "function_modifiers": return new FunctionModifiers(node);
                case "never_type": return new NeverType(node);
                case "union_item": return new UnionItem(node);
                case "const_block": return new ConstBlock(node);
                case "escape_sequence": return new EscapeSequence(node);
                case "struct_pattern": return new StructPattern(node);
                case "call_expression": return new CallExpression(node);
                case "type_parameters": return new TypeParameters(node);
                case "empty_statement": return new EmptyStatement(node);
                case "trait_bounds": return new TraitBounds(node);
                case "self": return new Self(node);
                case "abstract_type": return new AbstractType(node);
                case "trait_item": return new TraitItem(node);
                case "block": return new Block(node);
                case "closure_expression": return new ClosureExpression(node);
                case "index_expression": return new IndexExpression(node);
                case "while_expression": return new WhileExpression(node);
                case "token_tree": return new TokenTree(node);
                case "token_tree_pattern": return new TokenTreePattern(node);
                case "try_block": return new TryBlock(node);
                case "break_expression": return new BreakExpression(node);
                case "visibility_modifier": return new VisibilityModifier(node);
                case "enum_variant_list": return new EnumVariantList(node);
                case "function_item": return new FunctionItem(node);
                case "type_item": return new TypeItem(node);
                case "await_expression": return new AwaitExpression(node);
                case "field_expression": return new FieldExpression(node);
                case "type_arguments": return new TypeArguments(node);
                case "generic_type": return new GenericType(node);
                case "self_parameter": return new SelfParameter(node);
                case "shebang": return new Shebang(node);
                case "type_binding": return new TypeBinding(node);
                case "let_chain": return new LetChain(node);
                case "base_field_initializer": return new BaseFieldInitializer(node);
                case "macro_definition": return new MacroDefinition(node);
                case "for_expression": return new ForExpression(node);
                case "lifetime": return new Lifetime(node);
                case "parameter": return new Parameter(node);
                case "string_content": return new StringContent(node);
                case "static_item": return new StaticItem(node);
                case "ordered_field_declaration_list": return new OrderedFieldDeclarationList(node);
                case "scoped_use_list": return new ScopedUseList(node);
                case "source_file": return new SourceFile(node);
                case "tuple_pattern": return new TuplePattern(node);
                case "fragment_specifier": return new FragmentSpecifier(node);
                case "boolean_literal": return new BooleanLiteral(node);
                case "generic_type_with_turbofish": return new GenericTypeWithTurbofish(node);
                case "loop_expression": return new LoopExpression(node);
                case "declaration_list": return new DeclarationList(node);
                case "match_pattern": return new MatchPattern(node);
                case "closure_parameters": return new ClosureParameters(node);
                case "bracketed_type": return new BracketedType(node);
                case "reference_type": return new ReferenceType(node);
                case "token_repetition": return new TokenRepetition(node);
                case "assignment_expression": return new AssignmentExpression(node);
                case "scoped_identifier": return new ScopedIdentifier(node);
                case "parenthesized_expression": return new ParenthesizedExpression(node);
                case "const_parameter": return new ConstParameter(node);
                case "super": return new Super(node);
                case "mut_pattern": return new MutPattern(node);
                case "struct_item": return new StructItem(node);
                case "arguments": return new Arguments(node);
                case "enum_variant": return new EnumVariant(node);
                case "qualified_type": return new QualifiedType(node);
                case "type_identifier": return new TypeIdentifier(node);
                case "use_bounds": return new UseBounds(node);
                case "array_type": return new ArrayType(node);
                case "generic_pattern": return new GenericPattern(node);
                case "raw_string_literal": return new RawStringLiteral(node);
                case "generic_function": return new GenericFunction(node);
                case "variadic_parameter": return new VariadicParameter(node);
                case "range_pattern": return new RangePattern(node);
                case "impl_item": return new ImplItem(node);
                case "captured_pattern": return new CapturedPattern(node);
                case "macro_rule": return new MacroRule(node);
                case "doc_comment": return new DocComment(node);
                case "for_lifetimes": return new ForLifetimes(node);
                case "removed_trait_bound": return new RemovedTraitBound(node);
                case "function_signature_item": return new FunctionSignatureItem(node);
                case "extern_modifier": return new ExternModifier(node);
                case "parameters": return new Parameters(node);
                case "or_pattern": return new OrPattern(node);
                case "ERROR": return new ErrorNode(node);
                default: throw new System.ArgumentException("unknown node type: " + node.Kind, nameof(node));
            }
        }

    
        public string Kind { get; set; }

        protected RustLanguageNode(TreeSitter.Node node)
        {
            Kind = node.Kind;
        }
    }
    
    public class RustLanguageNodeTerminalNode : RustLanguageNode
    {
        public RustLanguageNodeTerminalNode(TreeSitter.Node node) : base(node)
        {
        }
    }
    
    public class ErrorNode : RustLanguageNode
    {
        public ErrorNode(TreeSitter.Node node) : base(node)
        {
        }
    }

    public interface IDeclarationStatement
    {
    }

    public interface IExpression
    {
    }

    public interface ILiteral : IExpression
    {
    }

    public interface ILiteralPattern : IPattern
    {
    }

    public interface IPattern
    {
    }

    public interface IType
    {
    }

    public class AbstractType : RustLanguageNode, IType
    {
        public RustLanguageNode Trait { get; set; }
        public System.Collections.Generic.List<TypeParameters> Children { get; set; }
        public AbstractType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "abstract_type");
            
            this.Trait = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("trait"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TypeParameters(x)).ToList();
        }
    }

    public class Arguments : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public Arguments(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "arguments");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrayExpression : RustLanguageNode, IExpression
    {
        public IExpression? Length { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ArrayExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_expression");
            
            {
                var tmp = node.ChildByFieldName("length");
                this.Length = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrayType : RustLanguageNode, IType
    {
        public IType Element { get; set; }
        public IExpression? Length { get; set; }
        public ArrayType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_type");
            
            this.Element = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("element"))!;
            {
                var tmp = node.ChildByFieldName("length");
                this.Length = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class AssignmentExpression : RustLanguageNode, IExpression
    {
        public IExpression Left { get; set; }
        public IExpression Right { get; set; }
        public AssignmentExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "assignment_expression");
            
            this.Left = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AssociatedType : RustLanguageNode, IDeclarationStatement
    {
        public TraitBounds? Bounds { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<WhereClause> Children { get; set; }
        public AssociatedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "associated_type");
            
            {
                var tmp = node.ChildByFieldName("bounds");
                this.Bounds = tmp is null ? null : new TraitBounds(tmp);
            }
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new WhereClause(x)).ToList();
        }
    }

    public class AsyncBlock : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public AsyncBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "async_block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class Attribute : RustLanguageNode
    {
        public TokenTree? Arguments { get; set; }
        public IExpression? Value { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public Attribute(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute");
            
            {
                var tmp = node.ChildByFieldName("arguments");
                this.Arguments = tmp is null ? null : new TokenTree(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AttributeItem : RustLanguageNode, IDeclarationStatement
    {
        public System.Collections.Generic.List<Attribute> Children { get; set; }
        public AttributeItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_item");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Attribute(x)).ToList();
        }
    }

    public class AwaitExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public AwaitExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "await_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BaseFieldInitializer : RustLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public BaseFieldInitializer(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "base_field_initializer");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BinaryExpression : RustLanguageNode, IExpression
    {
        public IExpression Left { get; set; }
        public RustLanguageNodeTerminalNode Operator { get; set; }
        public IExpression Right { get; set; }
        public BinaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "binary_expression");
            
            this.Left = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new RustLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class Block : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public Block(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BlockComment : RustLanguageNode
    {
        public DocComment? Doc { get; set; }
        public InnerDocCommentMarker? Inner { get; set; }
        public OuterDocCommentMarker? Outer { get; set; }
        public BlockComment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "block_comment");
            
            {
                var tmp = node.ChildByFieldName("doc");
                this.Doc = tmp is null ? null : new DocComment(tmp);
            }
            {
                var tmp = node.ChildByFieldName("inner");
                this.Inner = tmp is null ? null : new InnerDocCommentMarker(tmp);
            }
            {
                var tmp = node.ChildByFieldName("outer");
                this.Outer = tmp is null ? null : new OuterDocCommentMarker(tmp);
            }
        }
    }

    public class BooleanLiteral : RustLanguageNode, ILiteral, ILiteralPattern
    {
        public BooleanLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "boolean_literal");
            
        }
    }

    public class BoundedType : RustLanguageNode, IType
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public BoundedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "bounded_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BracketedType : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public BracketedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "bracketed_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BreakExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public BreakExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "break_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CallExpression : RustLanguageNode, IExpression
    {
        public Arguments Arguments { get; set; }
        public RustLanguageNode Function { get; set; }
        public CallExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "call_expression");
            
            this.Arguments = new Arguments(node.ChildByFieldName("arguments"));
            this.Function = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("function"))!;
        }
    }

    public class CapturedPattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<IPattern> Children { get; set; }
        public CapturedPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "captured_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPattern) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ClosureExpression : RustLanguageNode, IExpression
    {
        public RustLanguageNode Body { get; set; }
        public ClosureParameters Parameters { get; set; }
        public IType? ReturnType { get; set; }
        public ClosureExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "closure_expression");
            
            this.Body = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Parameters = new ClosureParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (IType) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class ClosureParameters : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ClosureParameters(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "closure_parameters");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CompoundAssignmentExpr : RustLanguageNode, IExpression
    {
        public IExpression Left { get; set; }
        public RustLanguageNodeTerminalNode Operator { get; set; }
        public IExpression Right { get; set; }
        public CompoundAssignmentExpr(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "compound_assignment_expr");
            
            this.Left = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new RustLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class ConstBlock : RustLanguageNode, IExpression, IPattern
    {
        public Block Body { get; set; }
        public ConstBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "const_block");
            
            this.Body = new Block(node.ChildByFieldName("body"));
        }
    }

    public class ConstItem : RustLanguageNode, IDeclarationStatement
    {
        public Identifier Name { get; set; }
        public IType Type { get; set; }
        public IExpression? Value { get; set; }
        public System.Collections.Generic.List<VisibilityModifier> Children { get; set; }
        public ConstItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "const_item");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VisibilityModifier(x)).ToList();
        }
    }

    public class ConstParameter : RustLanguageNode
    {
        public Identifier Name { get; set; }
        public IType Type { get; set; }
        public RustLanguageNode? Value { get; set; }
        public ConstParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "const_parameter");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class ContinueExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<Label> Children { get; set; }
        public ContinueExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "continue_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Label(x)).ToList();
        }
    }

    public class DeclarationList : RustLanguageNode
    {
        public System.Collections.Generic.List<IDeclarationStatement> Children { get; set; }
        public DeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IDeclarationStatement) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DynamicType : RustLanguageNode, IType
    {
        public RustLanguageNode Trait { get; set; }
        public DynamicType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "dynamic_type");
            
            this.Trait = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("trait"))!;
        }
    }

    public class ElseClause : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ElseClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "else_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EmptyStatement : RustLanguageNode, IDeclarationStatement
    {
        public EmptyStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "empty_statement");
            
        }
    }

    public class EnumItem : RustLanguageNode, IDeclarationStatement
    {
        public EnumVariantList Body { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public EnumItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_item");
            
            this.Body = new EnumVariantList(node.ChildByFieldName("body"));
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EnumVariant : RustLanguageNode
    {
        public RustLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public IExpression? Value { get; set; }
        public System.Collections.Generic.List<VisibilityModifier> Children { get; set; }
        public EnumVariant(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_variant");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VisibilityModifier(x)).ToList();
        }
    }

    public class EnumVariantList : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public EnumVariantList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_variant_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExpressionStatement : RustLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ExpressionStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "expression_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExternCrateDeclaration : RustLanguageNode, IDeclarationStatement
    {
        public Identifier? Alias { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ExternCrateDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "extern_crate_declaration");
            
            {
                var tmp = node.ChildByFieldName("alias");
                this.Alias = tmp is null ? null : new Identifier(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExternModifier : RustLanguageNode
    {
        public System.Collections.Generic.List<StringLiteral> Children { get; set; }
        public ExternModifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "extern_modifier");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new StringLiteral(x)).ToList();
        }
    }

    public class FieldDeclaration : RustLanguageNode
    {
        public FieldIdentifier Name { get; set; }
        public IType Type { get; set; }
        public System.Collections.Generic.List<VisibilityModifier> Children { get; set; }
        public FieldDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_declaration");
            
            this.Name = new FieldIdentifier(node.ChildByFieldName("name"));
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VisibilityModifier(x)).ToList();
        }
    }

    public class FieldDeclarationList : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public FieldDeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_declaration_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FieldExpression : RustLanguageNode, IExpression
    {
        public RustLanguageNode Field { get; set; }
        public IExpression Value { get; set; }
        public FieldExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_expression");
            
            this.Field = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("field"))!;
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class FieldInitializer : RustLanguageNode
    {
        public RustLanguageNode Field { get; set; }
        public IExpression Value { get; set; }
        public System.Collections.Generic.List<AttributeItem> Children { get; set; }
        public FieldInitializer(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_initializer");
            
            this.Field = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("field"))!;
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeItem(x)).ToList();
        }
    }

    public class FieldInitializerList : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public FieldInitializerList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_initializer_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FieldPattern : RustLanguageNode
    {
        public RustLanguageNode Name { get; set; }
        public IPattern? Pattern { get; set; }
        public System.Collections.Generic.List<MutableSpecifier> Children { get; set; }
        public FieldPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_pattern");
            
            this.Name = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("pattern");
                this.Pattern = tmp is null ? null : (IPattern) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MutableSpecifier(x)).ToList();
        }
    }

    public class ForExpression : RustLanguageNode, IExpression
    {
        public Block Body { get; set; }
        public IPattern Pattern { get; set; }
        public IExpression Value { get; set; }
        public System.Collections.Generic.List<Label> Children { get; set; }
        public ForExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_expression");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Pattern = (IPattern) RustLanguageNode.FromNode(node.ChildByFieldName("pattern"))!;
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Label(x)).ToList();
        }
    }

    public class ForLifetimes : RustLanguageNode
    {
        public System.Collections.Generic.List<Lifetime> Children { get; set; }
        public ForLifetimes(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_lifetimes");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Lifetime(x)).ToList();
        }
    }

    public class ForeignModItem : RustLanguageNode, IDeclarationStatement
    {
        public DeclarationList? Body { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ForeignModItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "foreign_mod_item");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FragmentSpecifier : RustLanguageNode
    {
        public FragmentSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "fragment_specifier");
            
        }
    }

    public class FunctionItem : RustLanguageNode, IDeclarationStatement
    {
        public Block Body { get; set; }
        public RustLanguageNode Name { get; set; }
        public Parameters Parameters { get; set; }
        public IType? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public FunctionItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_item");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Name = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Parameters = new Parameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (IType) RustLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FunctionModifiers : RustLanguageNode
    {
        public System.Collections.Generic.List<ExternModifier> Children { get; set; }
        public FunctionModifiers(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_modifiers");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ExternModifier(x)).ToList();
        }
    }

    public class FunctionSignatureItem : RustLanguageNode, IDeclarationStatement
    {
        public RustLanguageNode Name { get; set; }
        public Parameters Parameters { get; set; }
        public IType? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public FunctionSignatureItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_signature_item");
            
            this.Name = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Parameters = new Parameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (IType) RustLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FunctionType : RustLanguageNode, IType
    {
        public Parameters Parameters { get; set; }
        public IType? ReturnType { get; set; }
        public RustLanguageNode? Trait { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public FunctionType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_type");
            
            this.Parameters = new Parameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (IType) RustLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("trait");
                this.Trait = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GenBlock : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public GenBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "gen_block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class GenericFunction : RustLanguageNode, IExpression
    {
        public RustLanguageNode Function { get; set; }
        public TypeArguments TypeArguments { get; set; }
        public GenericFunction(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_function");
            
            this.Function = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("function"))!;
            this.TypeArguments = new TypeArguments(node.ChildByFieldName("type_arguments"));
        }
    }

    public class GenericPattern : RustLanguageNode, IPattern
    {
        public TypeArguments TypeArguments { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public GenericPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_pattern");
            
            this.TypeArguments = new TypeArguments(node.ChildByFieldName("type_arguments"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GenericType : RustLanguageNode, IType
    {
        public RustLanguageNode Type { get; set; }
        public TypeArguments TypeArguments { get; set; }
        public GenericType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_type");
            
            this.Type = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.TypeArguments = new TypeArguments(node.ChildByFieldName("type_arguments"));
        }
    }

    public class GenericTypeWithTurbofish : RustLanguageNode
    {
        public RustLanguageNode Type { get; set; }
        public TypeArguments TypeArguments { get; set; }
        public GenericTypeWithTurbofish(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_type_with_turbofish");
            
            this.Type = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.TypeArguments = new TypeArguments(node.ChildByFieldName("type_arguments"));
        }
    }

    public class HigherRankedTraitBound : RustLanguageNode
    {
        public IType Type { get; set; }
        public TypeParameters TypeParameters { get; set; }
        public HigherRankedTraitBound(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "higher_ranked_trait_bound");
            
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.TypeParameters = new TypeParameters(node.ChildByFieldName("type_parameters"));
        }
    }

    public class IfExpression : RustLanguageNode, IExpression
    {
        public ElseClause? Alternative { get; set; }
        public RustLanguageNode Condition { get; set; }
        public Block Consequence { get; set; }
        public IfExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "if_expression");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : new ElseClause(tmp);
            }
            this.Condition = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Consequence = new Block(node.ChildByFieldName("consequence"));
        }
    }

    public class ImplItem : RustLanguageNode, IDeclarationStatement
    {
        public DeclarationList? Body { get; set; }
        public RustLanguageNode? Trait { get; set; }
        public IType Type { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<WhereClause> Children { get; set; }
        public ImplItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "impl_item");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            {
                var tmp = node.ChildByFieldName("trait");
                this.Trait = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new WhereClause(x)).ToList();
        }
    }

    public class IndexExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public IndexExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "index_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InnerAttributeItem : RustLanguageNode, IDeclarationStatement
    {
        public System.Collections.Generic.List<Attribute> Children { get; set; }
        public InnerAttributeItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "inner_attribute_item");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Attribute(x)).ToList();
        }
    }

    public class InnerDocCommentMarker : RustLanguageNode
    {
        public InnerDocCommentMarker(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "inner_doc_comment_marker");
            
        }
    }

    public class Label : RustLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public Label(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "label");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class LetChain : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public LetChain(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "let_chain");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LetCondition : RustLanguageNode
    {
        public IPattern Pattern { get; set; }
        public IExpression Value { get; set; }
        public LetCondition(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "let_condition");
            
            this.Pattern = (IPattern) RustLanguageNode.FromNode(node.ChildByFieldName("pattern"))!;
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class LetDeclaration : RustLanguageNode, IDeclarationStatement
    {
        public Block? Alternative { get; set; }
        public IPattern Pattern { get; set; }
        public IType? Type { get; set; }
        public IExpression? Value { get; set; }
        public System.Collections.Generic.List<MutableSpecifier> Children { get; set; }
        public LetDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "let_declaration");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : new Block(tmp);
            }
            this.Pattern = (IPattern) RustLanguageNode.FromNode(node.ChildByFieldName("pattern"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) RustLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MutableSpecifier(x)).ToList();
        }
    }

    public class Lifetime : RustLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public Lifetime(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lifetime");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class LifetimeParameter : RustLanguageNode
    {
        public TraitBounds? Bounds { get; set; }
        public Lifetime Name { get; set; }
        public LifetimeParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lifetime_parameter");
            
            {
                var tmp = node.ChildByFieldName("bounds");
                this.Bounds = tmp is null ? null : new TraitBounds(tmp);
            }
            this.Name = new Lifetime(node.ChildByFieldName("name"));
        }
    }

    public class LineComment : RustLanguageNode
    {
        public DocComment? Doc { get; set; }
        public InnerDocCommentMarker? Inner { get; set; }
        public OuterDocCommentMarker? Outer { get; set; }
        public LineComment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "line_comment");
            
            {
                var tmp = node.ChildByFieldName("doc");
                this.Doc = tmp is null ? null : new DocComment(tmp);
            }
            {
                var tmp = node.ChildByFieldName("inner");
                this.Inner = tmp is null ? null : new InnerDocCommentMarker(tmp);
            }
            {
                var tmp = node.ChildByFieldName("outer");
                this.Outer = tmp is null ? null : new OuterDocCommentMarker(tmp);
            }
        }
    }

    public class LoopExpression : RustLanguageNode, IExpression
    {
        public Block Body { get; set; }
        public System.Collections.Generic.List<Label> Children { get; set; }
        public LoopExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "loop_expression");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Label(x)).ToList();
        }
    }

    public class MacroDefinition : RustLanguageNode, IDeclarationStatement
    {
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<MacroRule> Children { get; set; }
        public MacroDefinition(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "macro_definition");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MacroRule(x)).ToList();
        }
    }

    public class MacroInvocation : RustLanguageNode, IDeclarationStatement, IExpression, IPattern, IType
    {
        public RustLanguageNode Macro { get; set; }
        public System.Collections.Generic.List<TokenTree> Children { get; set; }
        public MacroInvocation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "macro_invocation");
            
            this.Macro = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("macro"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TokenTree(x)).ToList();
        }
    }

    public class MacroRule : RustLanguageNode
    {
        public TokenTreePattern Left { get; set; }
        public TokenTree Right { get; set; }
        public MacroRule(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "macro_rule");
            
            this.Left = new TokenTreePattern(node.ChildByFieldName("left"));
            this.Right = new TokenTree(node.ChildByFieldName("right"));
        }
    }

    public class MatchArm : RustLanguageNode
    {
        public MatchPattern Pattern { get; set; }
        public IExpression Value { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public MatchArm(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "match_arm");
            
            this.Pattern = new MatchPattern(node.ChildByFieldName("pattern"));
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MatchBlock : RustLanguageNode
    {
        public System.Collections.Generic.List<MatchArm> Children { get; set; }
        public MatchBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "match_block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MatchArm(x)).ToList();
        }
    }

    public class MatchExpression : RustLanguageNode, IExpression
    {
        public MatchBlock Body { get; set; }
        public IExpression Value { get; set; }
        public MatchExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "match_expression");
            
            this.Body = new MatchBlock(node.ChildByFieldName("body"));
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class MatchPattern : RustLanguageNode
    {
        public RustLanguageNode? Condition { get; set; }
        public System.Collections.Generic.List<IPattern> Children { get; set; }
        public MatchPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "match_pattern");
            
            {
                var tmp = node.ChildByFieldName("condition");
                this.Condition = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPattern) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ModItem : RustLanguageNode, IDeclarationStatement
    {
        public DeclarationList? Body { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<VisibilityModifier> Children { get; set; }
        public ModItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "mod_item");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new DeclarationList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VisibilityModifier(x)).ToList();
        }
    }

    public class MutPattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public MutPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "mut_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NegativeLiteral : RustLanguageNode, ILiteralPattern
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public NegativeLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "negative_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NeverType : RustLanguageNode, IType
    {
        public NeverType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "never_type");
            
        }
    }

    public class OrPattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<IPattern> Children { get; set; }
        public OrPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "or_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPattern) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OrderedFieldDeclarationList : RustLanguageNode
    {
        public System.Collections.Generic.List<IType> Type { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public OrderedFieldDeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ordered_field_declaration_list");
            
            this.Type = node.ChildrenByFieldName("type").Select(x => (IType) RustLanguageNode.FromNode(x)!).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OuterDocCommentMarker : RustLanguageNode
    {
        public OuterDocCommentMarker(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "outer_doc_comment_marker");
            
        }
    }

    public class Parameter : RustLanguageNode
    {
        public RustLanguageNode Pattern { get; set; }
        public IType Type { get; set; }
        public System.Collections.Generic.List<MutableSpecifier> Children { get; set; }
        public Parameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameter");
            
            this.Pattern = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("pattern"))!;
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MutableSpecifier(x)).ToList();
        }
    }

    public class Parameters : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public Parameters(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameters");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ParenthesizedExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PointerType : RustLanguageNode, IType
    {
        public IType Type { get; set; }
        public System.Collections.Generic.List<MutableSpecifier> Children { get; set; }
        public PointerType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "pointer_type");
            
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MutableSpecifier(x)).ToList();
        }
    }

    public class QualifiedType : RustLanguageNode
    {
        public IType Alias { get; set; }
        public IType Type { get; set; }
        public QualifiedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "qualified_type");
            
            this.Alias = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("alias"))!;
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class RangeExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public RangeExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "range_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RangePattern : RustLanguageNode, IPattern
    {
        public RustLanguageNode? Left { get; set; }
        public RustLanguageNode? Right { get; set; }
        public RangePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "range_pattern");
            
            {
                var tmp = node.ChildByFieldName("left");
                this.Left = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("right");
                this.Right = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class RawStringLiteral : RustLanguageNode, ILiteral, ILiteralPattern
    {
        public System.Collections.Generic.List<StringContent> Children { get; set; }
        public RawStringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "raw_string_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new StringContent(x)).ToList();
        }
    }

    public class RefPattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<IPattern> Children { get; set; }
        public RefPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPattern) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReferenceExpression : RustLanguageNode, IExpression
    {
        public IExpression Value { get; set; }
        public System.Collections.Generic.List<MutableSpecifier> Children { get; set; }
        public ReferenceExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "reference_expression");
            
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MutableSpecifier(x)).ToList();
        }
    }

    public class ReferencePattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ReferencePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "reference_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReferenceType : RustLanguageNode, IType
    {
        public IType Type { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ReferenceType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "reference_type");
            
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RemainingFieldPattern : RustLanguageNode, IPattern
    {
        public RemainingFieldPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "remaining_field_pattern");
            
        }
    }

    public class RemovedTraitBound : RustLanguageNode, IType
    {
        public System.Collections.Generic.List<IType> Children { get; set; }
        public RemovedTraitBound(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "removed_trait_bound");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IType) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReturnExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ReturnExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "return_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ScopedIdentifier : RustLanguageNode, IExpression, IPattern
    {
        public RustLanguageNode Name { get; set; }
        public RustLanguageNode? Path { get; set; }
        public ScopedIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "scoped_identifier");
            
            this.Name = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("path");
                this.Path = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class ScopedTypeIdentifier : RustLanguageNode, IType
    {
        public TypeIdentifier Name { get; set; }
        public RustLanguageNode? Path { get; set; }
        public ScopedTypeIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "scoped_type_identifier");
            
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("path");
                this.Path = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class ScopedUseList : RustLanguageNode
    {
        public UseList List { get; set; }
        public RustLanguageNode? Path { get; set; }
        public ScopedUseList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "scoped_use_list");
            
            this.List = new UseList(node.ChildByFieldName("list"));
            {
                var tmp = node.ChildByFieldName("path");
                this.Path = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
        }
    }

    public class SelfParameter : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public SelfParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "self_parameter");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ShorthandFieldInitializer : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public ShorthandFieldInitializer(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shorthand_field_initializer");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SlicePattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<IPattern> Children { get; set; }
        public SlicePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "slice_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPattern) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SourceFile : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public SourceFile(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "source_file");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StaticItem : RustLanguageNode, IDeclarationStatement
    {
        public Identifier Name { get; set; }
        public IType Type { get; set; }
        public IExpression? Value { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public StaticItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "static_item");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (IExpression) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StringLiteral : RustLanguageNode, ILiteral, ILiteralPattern
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public StringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StructExpression : RustLanguageNode, IExpression
    {
        public FieldInitializerList Body { get; set; }
        public RustLanguageNode Name { get; set; }
        public StructExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "struct_expression");
            
            this.Body = new FieldInitializerList(node.ChildByFieldName("body"));
            this.Name = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class StructItem : RustLanguageNode, IDeclarationStatement
    {
        public RustLanguageNode? Body { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public StructItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "struct_item");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (RustLanguageNode) RustLanguageNode.FromNode(tmp);
            }
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StructPattern : RustLanguageNode, IPattern
    {
        public RustLanguageNode Type { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public StructPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "struct_pattern");
            
            this.Type = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TokenBindingPattern : RustLanguageNode
    {
        public Metavariable Name { get; set; }
        public FragmentSpecifier Type { get; set; }
        public TokenBindingPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "token_binding_pattern");
            
            this.Name = new Metavariable(node.ChildByFieldName("name"));
            this.Type = new FragmentSpecifier(node.ChildByFieldName("type"));
        }
    }

    public class TokenRepetition : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TokenRepetition(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "token_repetition");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TokenRepetitionPattern : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TokenRepetitionPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "token_repetition_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TokenTree : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TokenTree(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "token_tree");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TokenTreePattern : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TokenTreePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "token_tree_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TraitBounds : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TraitBounds(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "trait_bounds");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TraitItem : RustLanguageNode, IDeclarationStatement
    {
        public DeclarationList Body { get; set; }
        public TraitBounds? Bounds { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TraitItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "trait_item");
            
            this.Body = new DeclarationList(node.ChildByFieldName("body"));
            {
                var tmp = node.ChildByFieldName("bounds");
                this.Bounds = tmp is null ? null : new TraitBounds(tmp);
            }
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TryBlock : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public TryBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "try_block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class TryExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public TryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "try_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TupleExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TuplePattern : RustLanguageNode, IPattern
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TuplePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleStructPattern : RustLanguageNode, IPattern
    {
        public RustLanguageNode Type { get; set; }
        public System.Collections.Generic.List<IPattern> Children { get; set; }
        public TupleStructPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_struct_pattern");
            
            this.Type = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPattern) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleType : RustLanguageNode, IType
    {
        public System.Collections.Generic.List<IType> Children { get; set; }
        public TupleType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IType) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeArguments : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TypeArguments(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_arguments");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeBinding : RustLanguageNode
    {
        public TypeIdentifier Name { get; set; }
        public IType Type { get; set; }
        public TypeArguments? TypeArguments { get; set; }
        public TypeBinding(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_binding");
            
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_arguments");
                this.TypeArguments = tmp is null ? null : new TypeArguments(tmp);
            }
        }
    }

    public class TypeCastExpression : RustLanguageNode, IExpression
    {
        public IType Type { get; set; }
        public IExpression Value { get; set; }
        public TypeCastExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_cast_expression");
            
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Value = (IExpression) RustLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class TypeItem : RustLanguageNode, IDeclarationStatement
    {
        public TypeIdentifier Name { get; set; }
        public IType Type { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TypeItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_item");
            
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            this.Type = (IType) RustLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeParameter : RustLanguageNode
    {
        public TraitBounds? Bounds { get; set; }
        public IType? DefaultType { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter");
            
            {
                var tmp = node.ChildByFieldName("bounds");
                this.Bounds = tmp is null ? null : new TraitBounds(tmp);
            }
            {
                var tmp = node.ChildByFieldName("default_type");
                this.DefaultType = tmp is null ? null : (IType) RustLanguageNode.FromNode(tmp);
            }
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
        }
    }

    public class TypeParameters : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public TypeParameters(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameters");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UnaryExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public UnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unary_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UnionItem : RustLanguageNode, IDeclarationStatement
    {
        public FieldDeclarationList Body { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public UnionItem(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "union_item");
            
            this.Body = new FieldDeclarationList(node.ChildByFieldName("body"));
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UnitExpression : RustLanguageNode, IExpression
    {
        public UnitExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unit_expression");
            
        }
    }

    public class UnitType : RustLanguageNode, IType
    {
        public UnitType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unit_type");
            
        }
    }

    public class UnsafeBlock : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public UnsafeBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unsafe_block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class UseAsClause : RustLanguageNode
    {
        public Identifier Alias { get; set; }
        public RustLanguageNode Path { get; set; }
        public UseAsClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "use_as_clause");
            
            this.Alias = new Identifier(node.ChildByFieldName("alias"));
            this.Path = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("path"))!;
        }
    }

    public class UseBounds : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public UseBounds(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "use_bounds");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UseDeclaration : RustLanguageNode, IDeclarationStatement
    {
        public RustLanguageNode Argument { get; set; }
        public System.Collections.Generic.List<VisibilityModifier> Children { get; set; }
        public UseDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "use_declaration");
            
            this.Argument = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("argument"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VisibilityModifier(x)).ToList();
        }
    }

    public class UseList : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public UseList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "use_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UseWildcard : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public UseWildcard(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "use_wildcard");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class VariadicParameter : RustLanguageNode
    {
        public IPattern? Pattern { get; set; }
        public System.Collections.Generic.List<MutableSpecifier> Children { get; set; }
        public VariadicParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variadic_parameter");
            
            {
                var tmp = node.ChildByFieldName("pattern");
                this.Pattern = tmp is null ? null : (IPattern) RustLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MutableSpecifier(x)).ToList();
        }
    }

    public class VisibilityModifier : RustLanguageNode
    {
        public System.Collections.Generic.List<RustLanguageNode> Children { get; set; }
        public VisibilityModifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "visibility_modifier");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (RustLanguageNode) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WhereClause : RustLanguageNode
    {
        public System.Collections.Generic.List<WherePredicate> Children { get; set; }
        public WhereClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "where_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new WherePredicate(x)).ToList();
        }
    }

    public class WherePredicate : RustLanguageNode
    {
        public TraitBounds Bounds { get; set; }
        public RustLanguageNode Left { get; set; }
        public WherePredicate(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "where_predicate");
            
            this.Bounds = new TraitBounds(node.ChildByFieldName("bounds"));
            this.Left = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("left"))!;
        }
    }

    public class WhileExpression : RustLanguageNode, IExpression
    {
        public Block Body { get; set; }
        public RustLanguageNode Condition { get; set; }
        public System.Collections.Generic.List<Label> Children { get; set; }
        public WhileExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "while_expression");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Condition = (RustLanguageNode) RustLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Label(x)).ToList();
        }
    }

    public class YieldExpression : RustLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public YieldExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "yield_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) RustLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CharLiteral : RustLanguageNode, ILiteral, ILiteralPattern
    {
        public CharLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "char_literal");
            
        }
    }

    public class Crate : RustLanguageNode
    {
        public Crate(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "crate");
            
        }
    }

    public class DocComment : RustLanguageNode
    {
        public DocComment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "doc_comment");
            
        }
    }

    public class EscapeSequence : RustLanguageNode
    {
        public EscapeSequence(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "escape_sequence");
            
        }
    }

    public class FieldIdentifier : RustLanguageNode
    {
        public FieldIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_identifier");
            
        }
    }

    public class FloatLiteral : RustLanguageNode, ILiteral, ILiteralPattern
    {
        public FloatLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "float_literal");
            
        }
    }

    public class Identifier : RustLanguageNode, IExpression, IPattern
    {
        public Identifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "identifier");
            
        }
    }

    public class IntegerLiteral : RustLanguageNode, ILiteral, ILiteralPattern
    {
        public IntegerLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "integer_literal");
            
        }
    }

    public class Metavariable : RustLanguageNode, IExpression, IType
    {
        public Metavariable(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "metavariable");
            
        }
    }

    public class MutableSpecifier : RustLanguageNode
    {
        public MutableSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "mutable_specifier");
            
        }
    }

    public class PrimitiveType : RustLanguageNode, IType
    {
        public PrimitiveType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "primitive_type");
            
        }
    }

    public class Self : RustLanguageNode, IExpression
    {
        public Self(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "self");
            
        }
    }

    public class Shebang : RustLanguageNode
    {
        public Shebang(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shebang");
            
        }
    }

    public class ShorthandFieldIdentifier : RustLanguageNode
    {
        public ShorthandFieldIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shorthand_field_identifier");
            
        }
    }

    public class StringContent : RustLanguageNode
    {
        public StringContent(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_content");
            
        }
    }

    public class Super : RustLanguageNode
    {
        public Super(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "super");
            
        }
    }

    public class TypeIdentifier : RustLanguageNode, IType
    {
        public TypeIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_identifier");
            
        }
    }
}